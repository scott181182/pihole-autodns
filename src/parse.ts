import { readdir } from "node:fs/promises";
import path from "node:path";

import type { ILogger } from "./logger";
import { isTruthy } from "./utils";

/**
 * Parse domain names from a list of Traefik router rules in a text file.
 * This file is expected to be generated by docker-gen, using the `traefik_rules.tpl.txt` file.
 */
export async function parseTraefikDomains(ruleFile: Blob): Promise<string[]> {
    const ruleData = await ruleFile.text();
    return ruleData
        .split(/[\n\r]+/)
        .map((line) => /Host\(`([^`]+)`\)/.exec(line)?.[1])
        .filter(isTruthy)
        .filter((host, i, arr) => arr.indexOf(host) === i);
}

/**
 * Parse a simple list of domain names from a file.
 * Domains are expected to be one-per-line.
 */
export async function parseDomains(file: Blob): Promise<string[]> {
    const filedata = await file.text();
    return filedata
        .split(/[\n\r]+/)
        .map((line) => line.trim())
        .filter(isTruthy);
}

export async function parseDomainsFromDirectory(directoryPath: string, logger: ILogger): Promise<Set<string>> {
    const domains = new Set<string>();
    const dirEntries = await readdir(directoryPath, { withFileTypes: true });

    if (dirEntries.length === 0) {
        logger.warn("No files found in data directory");
    }
    for (const entry of dirEntries) {
        if (!entry.isFile()) {
            logger.debug(`Skipping '${entry.name}' (not a file)`);
            continue;
        }

        const file = Bun.file(path.join(entry.parentPath, entry.name));
        if (entry.name.includes(".domains.")) {
            logger.debug(`Parsing '${entry.name}' as list of domains`);
            const whitelistDomains = await parseDomains(file);
            whitelistDomains.forEach((d) => {
                domains.add(d);
            });
        } else if (entry.name.includes(".traefik.")) {
            logger.debug(`Parsing '${entry.name}' as list of Traefik router rules`);
            const traefikDomains = await parseTraefikDomains(file);
            traefikDomains.forEach((d) => {
                domains.add(d);
            });
        } else {
            logger.warn(`Skipping '${entry.name}' (not sure how to parse)`);
        }
    }

    return domains;
}
