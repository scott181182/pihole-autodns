import { watch } from "fs/promises";

import { loadEnv } from "./env";
import { PiHoleClient } from "./pihole";
import { Logger } from "./logger";
import { diffArrays } from "./utils";
import { parseDomains, parseTraeficDomains } from "./parse";
import path from "path";



const TRAEFIC_RULES_FILENAME = "traefic_rules.txt";

const {
    PIHOLE_API_PATH,
    PIHOLE_PASSWORD,
    HOST_IP,
    DATA_DIRECTORY,
} = loadEnv("HOST_IP", "DATA_DIRECTORY", "PIHOLE_PASSWORD", "PIHOLE_API_PATH");
const WHITELIST_PATH = Bun.env.HOST_WHITELIST;



interface UpdateDomainNameOptions {
    /**
     * A file generated by docker-gen with Traefic rules.
     * Will be parsed by {@link parseTraeficDomains}.
     */
    traeficFile?: Bun.BunFile,
    /**
     * A file containing a newline-separated list of domains that should exist in PiHole, separate from the automatically detected ones.
     * Will be parsed by {@link parseDomains}.
     */
    whitelistFile?: Bun.BunFile,
}
/**
 * Reads what domains should be present in DNS records from passed in files, then reconciles this list of domains with the hosts registered with PiHole.
 */
async function reconcileDomainNames(client: PiHoleClient, ip: string, options: UpdateDomainNameOptions, logger: Logger) {
    const domains = new Set<string>();
    if(options.traeficFile) {
        logger.info("    Parsing Traefic hosts...");
        const traeficDomains = await parseTraeficDomains(options.traeficFile);
        traeficDomains.forEach((d) => domains.add(d));
    }

    if(options.whitelistFile) {
        logger.info("    Parsing whitelist...");
        const whitelistDomains = await parseDomains(options.whitelistFile);
        whitelistDomains.forEach((d) => domains.add(d));
    }

    await client.authenticate();
    const currentHosts = await client.getDnsHosts();
    const diff = diffArrays(currentHosts.map((h) => h.domain), domains);

    if(diff.add.size === 0 && diff.remove.size === 0) {
        logger.info("    No DNS changes to be made");
        return;
    }

    logger.info("    Found diff:");
    logger.info(
        diff.add.values().map((h) => `      + ${h}`).toArray().join("\n") +
        diff.remove.values().map((h) => `      - ${h}`).toArray().join("\n")
    );

    logger.info("    Sending Updates to PiHole API...");
    for(const toAdd of diff.add) {
        await client.addDnsHost(toAdd, ip);
    }
    for(const toRemove of diff.remove) {
        await client.removeDnsHost(toRemove, ip);
    }
    logger.info("    Done!");
}



const logger = new Logger();
async function main() {
    const client = new PiHoleClient(PIHOLE_API_PATH, PIHOLE_PASSWORD);

    const traeficFile = Bun.file(path.join(DATA_DIRECTORY, TRAEFIC_RULES_FILENAME));
    const options: UpdateDomainNameOptions = {
        traeficFile,
        whitelistFile: WHITELIST_PATH ? Bun.file(WHITELIST_PATH) : undefined,
    }
    if(await traeficFile.exists()) {
        logger.info(`Traefic file already exists at '${path.join(DATA_DIRECTORY, TRAEFIC_RULES_FILENAME)}', reconciling domain names...`);
        await reconcileDomainNames(client, HOST_IP, options, logger);
    }

    const watcher = watch(DATA_DIRECTORY, { encoding: "utf8" });
    for await(const event of watcher) {
        logger.info(`Detected change at '${path.join(DATA_DIRECTORY, event.filename ?? "")}', reconciling domain names...`);
        await reconcileDomainNames(client, HOST_IP, options, logger)
            .catch((err) => {
                if(err instanceof Error) {
                    logger.error(err.message);
                } else {
                    logger.error("An unknown error occurred updating domain names", { error: err });
                }
            });
    }
}
await main()
    .catch((err) => {
        if(err instanceof Error) {
            logger.error(err.message);
        } else {
            logger.error("An unknown error occurred", { error: err });
        }
    });
