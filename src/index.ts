import { watch } from "node:fs/promises";
import path from "node:path";

import { loadEnv } from "./env";
import { Logger } from "./logger";
import { parseDomains, parseTraefikDomains } from "./parse";
import { PiHoleClient } from "./pihole";
import { diffArrays } from "./utils";

const TRAEFIK_RULES_FILENAME = "traefik_rules.txt";

const { PIHOLE_API_PATH, PIHOLE_PASSWORD, HOST_IP, DATA_DIRECTORY } = loadEnv(
    "HOST_IP",
    "DATA_DIRECTORY",
    "PIHOLE_PASSWORD",
    "PIHOLE_API_PATH",
);
const WHITELIST_PATH = Bun.env.HOST_WHITELIST;

interface UpdateDomainNameOptions {
    /**
     * A file generated by docker-gen with Traefik rules.
     * Will be parsed by {@link parseTraefikDomains}.
     */
    traefikFile?: Bun.BunFile;
    /**
     * A file containing a newline-separated list of domains that should exist in PiHole, separate from the automatically detected ones.
     * Will be parsed by {@link parseDomains}.
     */
    whitelistFile?: Bun.BunFile;
}

/**
 * Reads what domains should be present in DNS records from passed in files, then reconciles this list of domains with the hosts registered with PiHole.
 */
async function reconcileDomainNames(
    client: PiHoleClient,
    ip: string,
    options: UpdateDomainNameOptions,
    logger: Logger,
) {
    const domains = new Set<string>();
    if (options.traefikFile) {
        logger.info("    Parsing Traefik hosts...");
        const traefikDomains = await parseTraefikDomains(options.traefikFile);
        traefikDomains.forEach((d) => {
            domains.add(d);
        });
    }

    if (options.whitelistFile) {
        logger.info("    Parsing whitelist...");
        const whitelistDomains = await parseDomains(options.whitelistFile);
        whitelistDomains.forEach((d) => {
            domains.add(d);
        });
    }

    await client.authenticate();
    const currentHosts = await client.getDnsHosts();
    const diff = diffArrays(
        currentHosts.map((h) => h.domain),
        domains,
    );

    if (diff.add.size === 0 && diff.remove.size === 0) {
        logger.info("    No DNS changes to be made");
        return;
    }

    logger.info("    Found diff:");
    const addDiffs = diff.add
        .values()
        .map((h) => `      + ${h}`)
        .toArray()
        .join("\n");
    const removeDiffs = diff.remove
        .values()
        .map((h) => `      - ${h}`)
        .toArray()
        .join("\n");
    logger.info(addDiffs + removeDiffs);

    logger.info("    Sending Updates to PiHole API...");
    for (const toAdd of diff.add) {
        await client.addDnsHost(toAdd, ip);
    }
    for (const toRemove of diff.remove) {
        await client.removeDnsHost(toRemove, ip);
    }
    logger.info("    Done!");
}

const logger = new Logger();
async function main() {
    const client = new PiHoleClient(PIHOLE_API_PATH, PIHOLE_PASSWORD);

    const traefikFile = Bun.file(path.join(DATA_DIRECTORY, TRAEFIK_RULES_FILENAME));
    const options: UpdateDomainNameOptions = {
        traefikFile,
        whitelistFile: WHITELIST_PATH ? Bun.file(WHITELIST_PATH) : undefined,
    };
    if (await traefikFile.exists()) {
        logger.info(
            `Traefik file already exists at '${path.join(DATA_DIRECTORY, TRAEFIK_RULES_FILENAME)}', reconciling domain names...`,
        );
        await reconcileDomainNames(client, HOST_IP, options, logger);
    }

    const watcher = watch(DATA_DIRECTORY, { encoding: "utf8" });
    for await (const event of watcher) {
        logger.info(
            `Detected change at '${path.join(DATA_DIRECTORY, event.filename ?? "")}', reconciling domain names...`,
        );
        await reconcileDomainNames(client, HOST_IP, options, logger).catch((err) => {
            if (err instanceof Error) {
                logger.error(err.message);
            } else {
                logger.error("An unknown error occurred updating domain names", { error: err });
            }
        });
    }
}
await main().catch((err) => {
    if (err instanceof Error) {
        logger.error(err.message);
    } else {
        logger.error("An unknown error occurred", { error: err });
    }
});
